<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="icon" href="/image0.jpg" type="image/x-icon">
    <title>Oneiblog</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://oneirical.github.io/style.css">
    <link rel="stylesheet" href="https://oneirical.github.io/color/green.css">

        <link rel="stylesheet" href="https://oneirical.github.io/color/background_pink.css">
    
    <link rel="stylesheet" href="https://oneirical.github.io/font-hack-subset.css">

    <meta name="description" content="">

    <meta property="og:description" content="">
    <meta property="og:title" content="Oneiblog">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://oneirical.github.io/csgamesos/">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:description" content="">
    <meta name="twitter:title" content="Oneiblog">
    <meta property="twitter:domain" content="oneirical.github.io">
    <meta property="twitter:url" content="https://oneirical.github.io/csgamesos/">

    </head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://oneirical.github.io" style="text-decoration: none;">
                    <div class="logo">
                      
                            Oneirical
                        
                    </div>
                </a>
            </div>
        </div>

        
        
                <nav class="menu">
            <ul class="menu__inner">
                <li class="active"><a href="https://oneirical.github.io">blog</a></li>
            
                <li><a href="https://oneirical.github.io/tags">tags</a></li>
            
                <li><a href="https://oneirical.github.io/archive">archive</a></li>
            
                <li><a href="https://oneirical.github.io/about">about me</a></li>
            
                <li><a href="https://github.com/oneirical" target="_blank" rel="noopener noreferrer">github</a></li>
            </ul>
        </nav>
    
    
        
    </header>
    

    <div class="content">
        
    <div class="post">
        
    <h1 class="post-title"><a href="https://oneirical.github.io/csgamesos/">Proper Work-Life Balance In The Packet Factory - First Place in Operating Systems at CS Games</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2024-03-18
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://oneirical.github.io/tags/networking/">#networking</a>&nbsp;
                <a class="post-tag" href="https://oneirical.github.io/tags/rust/">#rust</a>&nbsp;
                <a class="post-tag" href="https://oneirical.github.io/tags/writeups/">#writeups</a></span>
    

        <div class="post-content">
            <blockquote>
<p>&quot;We have discovered a file crawler in a mysterious PC containing an unfamiliar OS. The resistance believes that it could contain crucial information against the green threat. Therefore, your mission is to interact with it and extract all its secrets. But be careful: who knows what defence mechanisms this device may have?&quot;</p>
</blockquote>
<p>Well? How hard could this possibly be?</p>
<p>Spoiler: very much so.</p>
<p><strong><a href="https://github.com/Oneirical/OS-CSGAMES2024">Source Code</a></strong></p>
<h1 id="background">Background</h1>
<p>On the 15-16-17 weekend of March 2024, I participated in the <a href="https://csgames.org/en/">CS Games</a> competition for the first time, one of the largest undergraduate computer science contests in the noble province of Québec. I expected questionable odours, high levels of introversion and extremely difficult challenges. It appears only the latter conformed to my expectations, for the contenders truly did know how to party with the vast array of costumes, singing and loud electronic music at their disposition. Much to the chagrin of my fragile and sensitive ears.</p>
<p>I &quot;selected&quot; the challenges <strong>Operating Systems, Moldable Development and High Performance Computing</strong>. Since I am the only person who could not attend the Concordia introductory meeting, my team leaders chose for me - but I must celebrate their skill at making decisions in my place, for I thoroughly enjoyed two out of the three. Sorry, Moldable Development organizers, but I'd rather NOT drown in a deluge of UI micro-buttons and programming syntax hauled straight from the 1970s.</p>
<p>Mildly disappointed at the end of the competition, I sincerely thought I was going to win nothing. My bewildered face is now immortalized on the podium photo of the Operating Systems category, in the highly unexpected ranking of first place.</p>
<p>This post will reveal to you a fragment of the endured suffering.</p>
<h1 id="the-assignment">The Assignment</h1>
<p><a href="https://github.com/Oneirical/OS-CSGAMES2024/blob/master/instructions/os.en.md">You may read here the instructions given to me and my teammate, Jaspreet, at the beginning of this 3 hour battle.</a></p>
<p>If you, dear reader, are NOT a demigod of technology, your expression upon consulting this document may come to closely resemble mine at the time I opened this file for the first time:</p>

  
  
  <img src="https://raw.githubusercontent.com/Oneirical/oneirical.github.io/main/csgamesos/agony.png" alt="A slugcat screaming AAAAAAAAAAa" class="center" style="border-radius: 8px;" decoding="async" loading="lazy"/>

<p>First course of action: dumb it down a bit so that it may be parsed by my feeble brain where 50% of storage is clogged by fluffiness and pictures of cute cats. Clearly, we are dealing here with a MACHINE that RECEIVES THINGS, does some stuff with them, and outputs a transformed version of those THINGS.</p>
<p>Also known as a &quot;server&quot;. Yeah, I know what those are, right? I used to play Minecraft all the time on those! I can choose any programming language for this task...</p>
<p>The answer is obviously Rust. Sure, it has unimportant features like &quot;multithreading&quot;, &quot;memory safety&quot; or &quot;static typing&quot;, but what I truly care about is how its proponents occasionally possess profile pictures on Github of cute Pokémon wearing adorable bowties and ribbons. And, if someone got a job in technology with this little professionalism, then I would be wise to follow their every word of advice.</p>
<p>The challenge allows for use of any tool, including LLMs and full internet access. Sweet! It's just like working at a real job.</p>
<blockquote>
<p>Even ChatGPT won't save you. Good luck. - Mr Gorley, challenge organizer</p>
</blockquote>
<h1 id="things-in-and-out">Things, In And Out</h1>
<blockquote>
<p>Warning: I am a Biology undergraduate student self-teaching myself technology to escape the gulf of academia. I make mistakes. If anything in this post is wrong, I genuinely want to be corrected so that I may learn. Contact me at my email: julien-robert@videotron.ca, or message me on Discord - my username is &quot;oneirical&quot;.</p>
</blockquote>
<p>So, according to the intructions, the poor file crawler is currently throwing its delivery crates (&quot;packets&quot;) in the abyss known as &quot;port 7331&quot; where no one cares about it or gives it any attention. Let us fix that.</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">main</span><span>() -&gt; std::io::Result&lt;()&gt; {
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> listener = TcpListener::bind(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">127.0.0.1:7331</span><span style="color:#556633;">&quot;</span><span>)?;
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">for</span><span> stream in listener.incoming() {
</span><span>        </span><span style="color:#8fbfdc;">match</span><span> stream {
</span><span>            Ok(stream) =&gt; {
</span><span>                thread::spawn(</span><span style="color:#8fbfdc;">move </span><span>|| {
</span><span>                    handle_connection(stream).unwrap();
</span><span>                });
</span><span>            }
</span><span>            Err(e) =&gt; {
</span><span>                eprintln!(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Failed to accept connection; err = </span><span style="color:#7697d6;">{:?}</span><span style="color:#556633;">&quot;</span><span>, e);
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    Ok(())
</span><span>}
</span></code></pre>
<p>Now, I have no idea what a TCP or UDP stream is. I don't really remember what they mean, probably something like Tragically Cute Puppies or Unrealistically Desirable Pets. What I did, however, find out, is that when it comes to these kinds of server challenges, you'll usually want to make your connection follow the TCP type. Put a metaphorical pin in that, this will be relevant later.</p>
<p>Each &quot;stream&quot; is like a conveyor belt transporting packets into my little letterbox. All such streams should be correct (marked as &quot;Ok&quot;), in which case a &quot;thread&quot; will spawn to start taking care of the deliveries, like a <del>loyal servant</del> volunteer assigned to unpacking the delivery crates. This thread-worker needs to be able to actually touch the crates to do anything, so the &quot;move&quot; keyword transmits ownership of the data to them! Let's see what is happening inside the other end of the stream-conveyor-belt.</p>
<h2 id="packets-of-all-shapes-and-sizes">Packets Of All Shapes And Sizes</h2>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">enum </span><span style="color:#ffb964;">Packet </span><span>{
</span><span>    </span><span style="color:#7697d6;">UPLD </span><span>{ crawler_id: </span><span style="color:#8fbfdc;">u16</span><span>, file_path: String },
</span><span>    </span><span style="color:#7697d6;">MODE </span><span>{ mode: Mode },
</span><span>    </span><span style="color:#7697d6;">SEQN </span><span>{ seq_num: </span><span style="color:#8fbfdc;">u16 </span><span>},
</span><span>    </span><span style="color:#7697d6;">DATA </span><span>{ upload_id: </span><span style="color:#8fbfdc;">u16</span><span>, seq_num: </span><span style="color:#8fbfdc;">u16</span><span>, data: Vec&lt;</span><span style="color:#8fbfdc;">u8</span><span>&gt; },
</span><span>}
</span><span>
</span><span>#[</span><span style="color:#ffb964;">derive</span><span>(Clone, Copy)]
</span><span style="color:#8fbfdc;">enum </span><span style="color:#ffb964;">Mode </span><span>{
</span><span>    Block,
</span><span>    Compressed,
</span><span>}
</span></code></pre>
<p>Not all packets serve the same purpose! We want that juicy intel contained in those DATA packets, yes, but such precious payload is to be handled with care. To prepare ourselves, we have:</p>
<ul>
<li>UPLD packets announcing the arrival of a fresh delivery. They contain the identification number of the crawler (conveyor belt) from where the delivery is coming, and the file path in the source OS (&quot;country of origin&quot;) from which the data is getting extracted.</li>
<li>MODE packets only announce whether or not the incoming data is compressed and needs to have some water splashed onto it to revert to its original form, or if it's good as it currently is. Note the two Mode enums dictating this.</li>
<li>SEQN packets contain the &quot;sequence number&quot; of the packets. I am not as confident about these, but I believe they are counting what is the current number of DATA packets received, and if, for example, the next one will be the fifth or tenth one.</li>
</ul>
<h2 id="let-s-unpack-this">Let's Unpack This</h2>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">handle_connection</span><span>(</span><span style="color:#8fbfdc;">mut </span><span style="color:#ffb964;">stream</span><span>: TcpStream) -&gt; std::io::Result&lt;()&gt; {
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> buffer = [</span><span style="color:#cf6a4c;">0</span><span>; </span><span style="color:#cf6a4c;">508</span><span>]; </span><span style="color:#888888;">// Maximum packet size
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> mode: Mode;
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">loop </span><span>{
</span><span>        </span><span style="color:#8fbfdc;">let</span><span> n = </span><span style="color:#8fbfdc;">match</span><span> stream.read(&amp;</span><span style="color:#8fbfdc;">mut</span><span> buffer) {
</span><span>            Ok(n) </span><span style="color:#8fbfdc;">if</span><span> n == </span><span style="color:#cf6a4c;">0 </span><span>=&gt; </span><span style="color:#8fbfdc;">return </span><span>Ok(()), </span><span style="color:#888888;">// Connection closed
</span><span>            Ok(n) =&gt; n,
</span><span>            Err(e) =&gt; {
</span><span>                eprintln!(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Failed to read from socket; err = </span><span style="color:#7697d6;">{:?}</span><span style="color:#556633;">&quot;</span><span>, e);
</span><span>                </span><span style="color:#8fbfdc;">return </span><span>Err(e);
</span><span>            }
</span><span>        };
</span><span>
</span><span>        </span><span style="color:#888888;">// Parse the packet
</span><span>        </span><span style="color:#8fbfdc;">let</span><span> packet = parse_packet(&amp;buffer[..n]);
</span><span>        </span><span style="color:#8fbfdc;">match</span><span> packet {
</span><span>            Ok(packet) =&gt; {
</span><span>                </span><span style="color:#888888;">// Handle the packet
</span><span>                mode = </span><span style="color:#8fbfdc;">match</span><span> packet {
</span><span>                    Packet::</span><span style="color:#7697d6;">MODE </span><span>{ mode } =&gt; {
</span><span>                        mode
</span><span>                    },
</span><span>                    _ =&gt; Mode::Block,
</span><span>                };
</span><span>                handle_packet(&amp;</span><span style="color:#8fbfdc;">mut</span><span> stream, packet, mode)?;
</span><span>            }
</span><span>            Err(e) =&gt; {
</span><span>                eprintln!(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Failed to parse packet; err = </span><span style="color:#7697d6;">{:?}</span><span style="color:#556633;">&quot;</span><span>, e);
</span><span>                </span><span style="color:#888888;">// Send error response
</span><span>                send_error_response(&amp;</span><span style="color:#8fbfdc;">mut</span><span> stream, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Failed to parse packet</span><span style="color:#556633;">&quot;</span><span>)?;
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>Have a glance inside our &quot;volunteer&quot;'s crate-unpacking room. Because there is no such thing as sensible work-life balance in MY factory, their task continues eternally with the &quot;loop&quot; keyword (same thing as &quot;while true&quot;) until they are finally done and no further packets are coming out of the stream. The &quot;n&quot; variable is monitoring how many bytes are currently on the stream - how many crates remain on the conveyor belt, if you will. n = 0 returns Ok(()) and terminates our poor worker's employment.</p>
<p>&quot;508&quot; is the maximum size of a Packet, measured in bytes.</p>
<p>First, packets are <strong>parsed</strong>. This is because the shipping company sending these crates to us is laughably incompetent, and is basically just throwing a bunch of hexadecimal numbers on the conveyor belts wrapped in flimsy plastic packaging. The only way to identify where the crates begin and end, and what they actually are (UPLD, MODE, etc.) is through their <strong>header</strong>, a 10-byte sequence containing:</p>
<ul>
<li>2 bytes: Magic number 0xC505</li>
<li>2 bytes: Total packet size, including header</li>
<li>2 bytes: Crawler identifier</li>
<li>4 bytes: Command name in ASCII</li>
</ul>
<p>Basically, it's some cheap paper stickers slapped on top of the incoming transmission. We can do better. The &quot;parse_packet&quot; function makes all those messy bytes get tucked into a pristine box - the Packet enum shown earlier (UPLD, MODE, etc.) - all safe and sound for processing :3</p>
<p>I will demonstrate its inner workings in the following chapter. For now, the neatly processed Packet arrives in &quot;match packet&quot;, where a quick check verifies if our esteemed volunteer did their job correctly. Yes, sometimes, the incoming data contains spiky or dangerous things poking out - most importantly &quot;bit flips&quot; causing erronous tagging. This is a part of the assignment! Should that be detected by &quot;parse_packet&quot;, the &quot;match packet&quot; will throw the suspicious delivery into the incinerator of &quot;send_error_response&quot;, where it shall be destroyed:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">send_error_response</span><span>(</span><span style="color:#ffb964;">socket</span><span>: &amp;</span><span style="color:#8fbfdc;">mut</span><span> TcpStream, </span><span style="color:#ffb964;">message</span><span>: &amp;</span><span style="color:#8fbfdc;">str</span><span>) -&gt; std::io::Result&lt;()&gt; {
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> response = format!(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">IAMERR\x00</span><span style="color:#7697d6;">{:02X}{}</span><span style="color:#556633;">&quot;</span><span>, message.len() + </span><span style="color:#cf6a4c;">4</span><span>, message);
</span><span>    socket.write_all(response.as_bytes())?;
</span><span>    Ok(())
</span><span>}
</span></code></pre>
<p>Hopefully, the next packet will fare better than its predecessor.</p>
<p>Let us return our attention to jobs well done - instances of &quot;Ok(packet)&quot;. First, we check if we are currently dealing with a MODE packet - if yes, change the current active mode to match it - this will enable or disable the miraculous Decompressor 9000 located inside &quot;handle_packet&quot;. We shall return to that later.</p>
<h2 id="nice-and-tidy-boxes">Nice And Tidy Boxes</h2>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">parse_packet</span><span>(</span><span style="color:#ffb964;">data</span><span>: &amp;[</span><span style="color:#8fbfdc;">u8</span><span>]) -&gt; Result&lt;Packet, &amp;</span><span style="color:#8fbfdc;">&#39;static str</span><span>&gt; {
</span><span>    </span><span style="color:#888888;">// Check if the data is long enough to contain a header
</span><span>    </span><span style="color:#8fbfdc;">if</span><span> data.len() &lt; </span><span style="color:#cf6a4c;">10 </span><span>{
</span><span>        </span><span style="color:#8fbfdc;">return </span><span>Err(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Packet too short</span><span style="color:#556633;">&quot;</span><span>);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#888888;">// Parse the header
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> magic_number = </span><span style="color:#8fbfdc;">u16</span><span>::from_be_bytes([data[</span><span style="color:#cf6a4c;">0</span><span>], data[</span><span style="color:#cf6a4c;">1</span><span>]]);
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> total_packet_size = </span><span style="color:#8fbfdc;">u16</span><span>::from_be_bytes([data[</span><span style="color:#cf6a4c;">2</span><span>], data[</span><span style="color:#cf6a4c;">3</span><span>]]);
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> crawler_id = </span><span style="color:#8fbfdc;">u16</span><span>::from_be_bytes([data[</span><span style="color:#cf6a4c;">4</span><span>], data[</span><span style="color:#cf6a4c;">5</span><span>]]);
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> command_name = &amp;data[</span><span style="color:#cf6a4c;">6</span><span>..</span><span style="color:#cf6a4c;">10</span><span>];
</span><span>
</span><span>    </span><span style="color:#888888;">// Validate the magic number
</span><span>    
</span><span>    </span><span style="color:#8fbfdc;">if</span><span> magic_number != </span><span style="color:#cf6a4c;">0xC505 </span><span>{
</span><span>        </span><span style="color:#8fbfdc;">return </span><span>Err(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Invalid magic number</span><span style="color:#556633;">&quot;</span><span>);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#888888;">// Validate that the received data is of the expected length
</span><span>    </span><span style="color:#8fbfdc;">if</span><span> data.len() != total_packet_size as </span><span style="color:#8fbfdc;">usize </span><span>{
</span><span>        </span><span style="color:#8fbfdc;">return </span><span>Err(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Packet size mismatch</span><span style="color:#556633;">&quot;</span><span>);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#888888;">// Determine the packet type based on the command name
</span><span>    </span><span style="color:#8fbfdc;">match</span><span> command_name {
</span><span>        </span><span style="color:#8fbfdc;">b</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">UPLD</span><span style="color:#556633;">&quot; </span><span>=&gt; {
</span><span>            </span><span style="color:#888888;">// Parse the UPLD packet
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> file_path = String::from_utf8_lossy(&amp;data[</span><span style="color:#cf6a4c;">10</span><span>..]).to_string();
</span><span>            Ok(Packet::</span><span style="color:#7697d6;">UPLD </span><span>{ crawler_id, file_path })
</span><span>        },
</span><span>        </span><span style="color:#8fbfdc;">b</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">MODE</span><span style="color:#556633;">&quot; </span><span>=&gt; {
</span><span>            </span><span style="color:#888888;">// Parse the MODE packet
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> new_mode = </span><span style="color:#8fbfdc;">match </span><span>String::from_utf8_lossy(&amp;data[</span><span style="color:#cf6a4c;">10</span><span>..]).as_ref() {
</span><span>                </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">block</span><span style="color:#556633;">&quot; </span><span>=&gt; Mode::Block,
</span><span>                </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">compressed</span><span style="color:#556633;">&quot; </span><span>=&gt; Mode::Compressed,
</span><span>                _ =&gt; Mode::Block,
</span><span>            };
</span><span>            Ok(Packet::</span><span style="color:#7697d6;">MODE </span><span>{ mode: new_mode })
</span><span>        },
</span><span>        </span><span style="color:#8fbfdc;">b</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">SEQN</span><span style="color:#556633;">&quot; </span><span>=&gt; {
</span><span>            </span><span style="color:#888888;">// Parse the SEQN packet
</span><span>            </span><span style="color:#8fbfdc;">if</span><span> data.len() &lt; </span><span style="color:#cf6a4c;">12 </span><span>{
</span><span>                </span><span style="color:#8fbfdc;">return </span><span>Err(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Packet too short for SEQN</span><span style="color:#556633;">&quot;</span><span>);
</span><span>            }
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> seq_num = </span><span style="color:#8fbfdc;">u16</span><span>::from_be_bytes([data[</span><span style="color:#cf6a4c;">10</span><span>], data[</span><span style="color:#cf6a4c;">11</span><span>]]);
</span><span>            Ok(Packet::</span><span style="color:#7697d6;">SEQN </span><span>{ seq_num })
</span><span>        },
</span><span>        </span><span style="color:#8fbfdc;">b</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">DATA</span><span style="color:#556633;">&quot; </span><span>=&gt; {
</span><span>            </span><span style="color:#888888;">// Parse the DATA packet
</span><span>            </span><span style="color:#8fbfdc;">if</span><span> data.len() &lt; </span><span style="color:#cf6a4c;">14 </span><span>{
</span><span>                </span><span style="color:#8fbfdc;">return </span><span>Err(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Packet too short for DATA</span><span style="color:#556633;">&quot;</span><span>);
</span><span>            }
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> upload_id = </span><span style="color:#8fbfdc;">u16</span><span>::from_be_bytes([data[</span><span style="color:#cf6a4c;">10</span><span>], data[</span><span style="color:#cf6a4c;">11</span><span>]]);
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> seq_num = </span><span style="color:#8fbfdc;">u16</span><span>::from_be_bytes([data[</span><span style="color:#cf6a4c;">12</span><span>], data[</span><span style="color:#cf6a4c;">13</span><span>]]);
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> data = data[</span><span style="color:#cf6a4c;">14</span><span>..].to_vec();
</span><span>            Ok(Packet::</span><span style="color:#7697d6;">DATA </span><span>{ upload_id, seq_num, data })
</span><span>        },
</span><span>        _ =&gt; Err(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Unknown command</span><span style="color:#556633;">&quot;</span><span>),
</span><span>    }
</span><span>}
</span></code></pre>
<p>Ah, the glorious packaging facility. Where the unruly and chaotic come to be crushed and rearranged into flawless order and conformity.</p>
<p>First, we ensure that the header - that flimy paper tag - actually exists. We check that at least 10 bytes are present, then begin slotting them into their respective categories. &quot;from_be_bytes&quot; is swapping out those pesky hexadecimal tags (C5 05 00 1B 00 01 55 50, ewww!) into a glorious human-readable number.</p>
<p>We then check that 1. the magic number is present, and that 2. the packet size written in the header actually corresponds to its real weight. If you've played Papers Please, it's just like weighing people at the customs on a scale to make sure they aren't hiding any contraband.</p>
<p>Should everything appear in order, we then package the contents! The &quot;b&quot; before each match statement is parsing the Packet type as a &quot;byte string&quot; - because the aforementioned incompetent packaging company, of course, just HAD to give us numbers, and not human-readable letters!</p>
<p>Cracking open what is inside the Packet allows us to fill up each field of the Packet enum (for example, DATA contains upload_id, seq_num and data). This finalized version is what is shipped to &quot;handle_packet&quot;, covered in the next chapter.</p>
<h2 id="payment-received">Payment Received</h2>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">handle_packet</span><span>(</span><span style="color:#ffb964;">socket</span><span>: &amp;</span><span style="color:#8fbfdc;">mut</span><span> TcpStream, </span><span style="color:#ffb964;">packet</span><span>: Packet, </span><span style="color:#ffb964;">mode</span><span>: Mode) -&gt; std::io::Result&lt;()&gt; {
</span><span>    </span><span style="color:#8fbfdc;">match</span><span> packet {
</span><span>        Packet::</span><span style="color:#7697d6;">UPLD </span><span>{ crawler_id, file_path } =&gt; {
</span><span>            </span><span style="color:#888888;">// Acknowledge the upload
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> response = format!(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">UPLOADING\x00</span><span style="color:#7697d6;">{:02X}</span><span style="color:#556633;">&quot;</span><span>, crawler_id);
</span><span>            socket.write_all(response.as_bytes())?;
</span><span>            Ok(())
</span><span>        }
</span><span>        Packet::</span><span style="color:#7697d6;">MODE </span><span>{ mode } =&gt; {
</span><span>            </span><span style="color:#888888;">// Acknowledge the MODE packet
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> response = format!(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">METADATAMODE</span><span style="color:#556633;">&quot;</span><span>);
</span><span>            socket.write_all(response.as_bytes())?;
</span><span>            Ok(())
</span><span>        }
</span><span>        Packet::</span><span style="color:#7697d6;">SEQN </span><span>{ seq_num } =&gt; {
</span><span>            </span><span style="color:#888888;">// Acknowledge the SEQN packet
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> response = format!(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">METADATASEQN</span><span style="color:#556633;">&quot;</span><span>);
</span><span>            socket.write_all(response.as_bytes())?;
</span><span>            Ok(())
</span><span>        }
</span><span>        Packet::</span><span style="color:#7697d6;">DATA </span><span>{ upload_id, seq_num, </span><span style="color:#8fbfdc;">mut</span><span> data } =&gt; {
</span><span>            </span><span style="color:#888888;">// Handle DATA packet
</span><span>            </span><span style="color:#8fbfdc;">match</span><span> mode {
</span><span>                Mode::Block =&gt; {
</span><span>                    </span><span style="color:#888888;">// Handle block mode data
</span><span>                },
</span><span>                Mode::Compressed =&gt; {
</span><span>                    </span><span style="color:#888888;">// Handle compressed mode data
</span><span>                    data = decompress_rle(&amp;data);
</span><span>                },
</span><span>            }
</span><span>            handle_data_packet(socket, upload_id, seq_num, data)
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>Receiving an UPLD, MODE or SEQN packet isn't very complicated. We pretty much only need to scream out that we got it, and it stops there. In the case of MODE packets, we already used its contents to swap the current active mode to Block or Compressed. DATA Packets are much more interesting...</p>
<p>First, they may or may not face the aforementioned Decompressor 9000. Observe, and be awed:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">decompress_rle</span><span>(</span><span style="color:#ffb964;">data</span><span>: &amp;[</span><span style="color:#8fbfdc;">u8</span><span>]) -&gt; Vec&lt;</span><span style="color:#8fbfdc;">u8</span><span>&gt; {
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> result = Vec::new();
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> index = </span><span style="color:#cf6a4c;">0</span><span>;
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">while</span><span> index &lt; data.len() {
</span><span>        </span><span style="color:#8fbfdc;">let</span><span> value = data[index];
</span><span>        </span><span style="color:#8fbfdc;">let</span><span> count = data[index + </span><span style="color:#cf6a4c;">1</span><span>];
</span><span>        result.resize(result.len() + count as </span><span style="color:#8fbfdc;">usize</span><span>, value);
</span><span>        index += </span><span style="color:#cf6a4c;">2</span><span>;
</span><span>    }
</span><span>
</span><span>    result
</span><span>}
</span></code></pre>
<blockquote>
<p>&quot;RLE is a form of lossless data compression in which runs (a run is sequence of consecutive values that are the same) of data are stored as a single count and data value.</p>
</blockquote>
<p>I'm sorry, dear Mr Gorley - the competition organizer - but my hands were already quite full. I just looked up RLE decompression online, and translated the code into Rust. Forgive me, Linus Torvalds.</p>

  
  
  <img src="https://raw.githubusercontent.com/Oneirical/oneirical.github.io/main/csgamesos/wpvtr5pmskfc1.webp" alt="You copied code without understanding it, as a result your code is trash. AGAIN." class="left" style="border-radius: 8px;" decoding="async" loading="lazy"/>

<p>Following this process, DATA packets are sent to the final step of their journey:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">handle_data_packet</span><span>(</span><span style="color:#ffb964;">socket</span><span>: &amp;</span><span style="color:#8fbfdc;">mut</span><span> TcpStream, </span><span style="color:#ffb964;">upload_id</span><span>: </span><span style="color:#8fbfdc;">u16</span><span>, </span><span style="color:#ffb964;">seq_num</span><span>: </span><span style="color:#8fbfdc;">u16</span><span>, </span><span style="color:#ffb964;">data</span><span>: Vec&lt;</span><span style="color:#8fbfdc;">u8</span><span>&gt;) -&gt; std::io::Result&lt;()&gt; {
</span><span>    
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> clean_data = remove_redundant_bits(&amp;data);
</span><span>    
</span><span>    </span><span style="color:#888888;">// Example: Write data to a file named after the upload_id
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> file_path = format!(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">upload_</span><span style="color:#7697d6;">{}</span><span style="color:#99ad6a;">.bin</span><span style="color:#556633;">&quot;</span><span>, upload_id);
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> file = OpenOptions::new()
</span><span>        .write(true)
</span><span>        .append(true)
</span><span>        .create(true)
</span><span>        .open(file_path)?;
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> writer = BufWriter::new(file);
</span><span>    writer.write_all(&amp;clean_data)?;
</span><span>
</span><span>    </span><span style="color:#888888;">// If the data is empty, this is the end of the file transfer
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> file_path = format!(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">upload_</span><span style="color:#7697d6;">{}</span><span style="color:#99ad6a;">.bin</span><span style="color:#556633;">&quot;</span><span>, upload_id);
</span><span>    </span><span style="color:#8fbfdc;">if</span><span> data.is_empty() {
</span><span>        </span><span style="color:#888888;">// Send a response indicating the upload is complete
</span><span>        </span><span style="color:#8fbfdc;">let</span><span> response = format!(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">UPLOAD END\x00</span><span style="color:#7697d6;">{}</span><span style="color:#556633;">&quot;</span><span>, file_path);
</span><span>        socket.write_all(response.as_bytes())?;
</span><span>    }
</span><span>
</span><span>    Ok(())
</span><span>}
</span></code></pre>
<p>That &quot;clean_data&quot; step is a real brain liquefier. I'll come back to it later, I still do not fully understand it.</p>
<p>In order to capture that sweet intel, we need a place to store it. That is a file - possibly the most &quot;Operating Systems&quot; part of this challenge... As far as I am aware, most of the work done so far is more in the realm of Networking. And not the &quot;talking to ambitious entrepreneurs at a fancy cocktail&quot; type, I had my fair share of that one too at the CS Games ending banquet.</p>
<p>This file has full permissions, and has the entire contents of the data field of the DATA packet dumped into it. The end of this task is announced with the glorious victory chant of &quot;UPLOAD END&quot;. Such celebrations must not last long - the next packet awaiting processing is already on the way...</p>
<h2 id="the-part-where-it-sucked">The Part Where It Sucked</h2>
<p>Alright, so:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">remove_redundant_bits</span><span>(</span><span style="color:#ffb964;">data</span><span>: &amp;[</span><span style="color:#8fbfdc;">u8</span><span>]) -&gt; Vec&lt;</span><span style="color:#8fbfdc;">u8</span><span>&gt; {
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> result = Vec::new();
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> buffer = </span><span style="color:#cf6a4c;">0</span><span style="color:#8fbfdc;">u16</span><span>; </span><span style="color:#888888;">// Temporary buffer to hold 2 bytes of data
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> bit_count = </span><span style="color:#cf6a4c;">0</span><span>; </span><span style="color:#888888;">// Keeps track of the number of bits processed
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">for </span><span>&amp;byte in data {
</span><span>        buffer = (buffer &lt;&lt; </span><span style="color:#cf6a4c;">8</span><span>) | (byte as </span><span style="color:#8fbfdc;">u16</span><span>); </span><span style="color:#888888;">// Shift the buffer and add the new byte
</span><span>        bit_count += </span><span style="color:#cf6a4c;">8</span><span>; </span><span style="color:#888888;">// Increment the bit count
</span><span>
</span><span>        </span><span style="color:#888888;">// Process 2 bytes of data at a time
</span><span>        </span><span style="color:#8fbfdc;">while</span><span> bit_count &gt;= </span><span style="color:#cf6a4c;">9 </span><span>{
</span><span>            </span><span style="color:#888888;">// Extract 9 bits from the buffer
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> value = (buffer &gt;&gt; (bit_count - </span><span style="color:#cf6a4c;">9</span><span>)) &amp; </span><span style="color:#cf6a4c;">0x1FF</span><span>; </span><span style="color:#888888;">// Mask to keep only the last 9 bits
</span><span>            result.push(value as </span><span style="color:#8fbfdc;">u8</span><span>); </span><span style="color:#888888;">// Add the value to the result
</span><span>            bit_count -= </span><span style="color:#cf6a4c;">9</span><span>; </span><span style="color:#888888;">// Update the bit count
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#888888;">// Handle any remaining bits in the buffer
</span><span>    </span><span style="color:#8fbfdc;">if</span><span> bit_count &gt; </span><span style="color:#cf6a4c;">0 </span><span>{
</span><span>        </span><span style="color:#8fbfdc;">let</span><span> value = buffer &amp; ((</span><span style="color:#cf6a4c;">1 </span><span>&lt;&lt; bit_count) - </span><span style="color:#cf6a4c;">1</span><span>); </span><span style="color:#888888;">// Mask to keep only the last bit_count bits
</span><span>        result.push(value as </span><span style="color:#8fbfdc;">u8</span><span>); </span><span style="color:#888888;">// Add the value to the result
</span><span>    }
</span><span>
</span><span>    result
</span><span>}
</span></code></pre>
<p>This is my attempt at making SOMETHING that would somewhat resemble the challenge requirement about Hamming codes. That part could have been written in Swahili and I would have probably understood it better.</p>
<p>I mean, just look at this:</p>
<blockquote>
<p>We can see that G<sub>0000</sub>, P<sub>0001</sub>, and P<sub>0010</sub> don't hold. We therefore know that bit 3<sub>0011</sub> was flipped, because <code>0001 | 0010 = 0011</code>. ORing/adding the positions of the parity bits that have an error gives the position of the errorneous bit.</p>
</blockquote>
<p>I beg your pardon?</p>
<p>In the challenge description, there is this tiny line of text: &quot;Redundant bits should be <em>removed</em> from the received data before saving to disk&quot;. I wondered if that had anything to do with &quot;Hamming error correction&quot;. This resulted in hacked-together code in the final 30 minutes of the challenge, knit together from StackOverflow and LLM outputs. I understand what it does - it repeatedly combines the last byte in each buffer with a new byte, preparing for the next 9-bit extraction. This effectively makes little bundles of 9 bits and will drop any overflowing or redundant bits not part of the bundling process.</p>
<p>I'm pretty sure this has nothing to do with the Hamming-thingimagibob. I would obviously spend time and effort learning it in an actual job, but it wasn't something I could fit within the 3 hour time delay.</p>
<h3 id="edit-worlds-ender-s-solution">EDIT: Worlds Ender's Solution</h3>
<p>After posting this blog on <a href="https://www.reddit.com/r/rust/comments/1birmmm/how_rusts_robustness_saved_my_undergraduate/kvoriof/?context=10">Reddit</a>, a highly dedicated user going by the name of <a href="https://github.com/WorldSEnder">WorldsEnder</a> - possibly about 2 or 3 planes of existence above my own level of technowizardry - decided to implement parity checking as a fun challenge. They mentioned how a minimum viable product took 30 minutes, and the polished version, 3 whole hours! If someone on this level of expertise took that long, actually implementing this in the competition would have been a distant dream. I am glad I wasted little time on it.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=c76cddc9a85d3bf79e3197933191eed5">You may find their code here.</a></p>
<p>If you, Internet wanderer, is currently feeling as confused by this theory as I previously was, please check out <a href="https://www.youtube.com/watch?v=X8jsijhllIA">3Blue1Brown's video on the topic</a>! There is also a follow-up on the implementation itself.</p>
<h2 id="final-scoring">Final Scoring</h2>
<p>I was told my final score was 48/58, which <em>really</em> surprised me. I was imagining every other university team flawlessly implementing that Hamming error correction feature and annihilating us.</p>
<p>There was a Python script provided with the challenge, meant to &quot;test&quot; our server. However, it contained more bugs than my previous internship in entomological research, so I disregarded it entirely. Jaspreet, my teammate, had the brilliant idea to test the connection by simply plugging the IP address in the web browser, which gave us a big confidence boost when we found out the packet input was indeed successful. However, this was <em>not</em> real testing. I pretty much shipped the entire code for review in pure YOLO action.</p>
<p>It appears other teams DID manage to fix and use the script. They listened to the outgoing connection with Wireshark, and found out the protocol in use was UDP, and <em>not</em> TCP like we chose. I got crushed when I first heard this, as this would basically mean that our entire program would not work at all. At this point, I became convinced of my utmost failure.</p>
<p>However, the judge, in his magnanimity, only deducted a few points for this. After all, as far as I'm aware, changing the protocol wouldn't be so hard - just a matter of swapping out a function here and there.</p>
<p>The Université de Montréal team, who came in second place, visited me after the announcement of victory, saying that they found it quite weird that they did not get first place. They mentioned how they managed to implement every feature, including Hamming correction, and that they tested their code extensively using a modified version of the Python script. In fact, I remember them spending a LOT of time debugging it and showing newfound mistakes to the competition organizer. </p>
<p>Personally, I preferred to use that time to polish the error handling of my server. Testing isn't as mandatory in Rust - if the compiler accepts it, it has a good chance of working on the first try!</p>
<p>Anyhow, I invite the UdeM team, who may be reading this, to open source their code like I did. I am intrigued to see how you two managed to implement that mysterious Hamming error correction feature.</p>
<h1 id="special-thanks">Special Thanks</h1>
<ul>
<li><a href="https://github.com/Artypuppet">Jaspreet</a>, my teammate for this challenge. You may not know Rust, but I am glad you agreed to let me use it for our code. Your ideas and discussions really propelled the project forwards, and your idea near the end to use a web browser to test the connection removed so much stress off my shoulders!</li>
</ul>
<blockquote>
<p>&quot;It's actually making me want to learn rust right now.&quot;</p>
</blockquote>
<ul>
<li><a href="https://github.com/eievui5/">Evie</a>, my most highly esteemed mentor and grand Rust arch-sorceress. Working on <a href="https://github.com/ISSOtm/rsgbds/pull/2">RGBFIX</a> - a Game Boy ROM fixing tool - under your guidance before attempting this challenge helped <em>tremendously</em>, from proper error handling, to read/write operations, and, of course, parsing hexadecimal headers. Beyond your knowledge, you are also an amazing friend, and talking to you is one of the things I look the most forward to daily.</li>
</ul>
<blockquote>
<p>&quot;I’m really happy for you. I can’t believe you were convinced you failed and then got first place :3&quot;</p>
</blockquote>
<p><em>If you enjoyed this writeup, feel free to contact me! I am currently looking for:</em></p>
<ul>
<li><em>Summer internships</em></li>
<li><em>Full time positions after April 2025</em></li>
<li><em>People to join my Northsec team - no large proficiency in security required, but the drive to learn about technology is mandatory</em></li>
</ul>
<p><em>Discord: oneirical</em></p>
<p><em>Email: julien-robert@videotron.ca</em></p>

        </div>

        
        <div class="pagination">
            <div class="pagination__title">
                <span class="pagination__title-h"></span>
                <hr />
            </div>
            <div class="pagination__buttons">
                    <span class="button previous">
                        <a href="https://oneirical.github.io/05-01-24-advent-of-great-trials/">
                            <span class="button__icon">←</span>&nbsp;
                            <span class="button__text">Advent of Great Trials</span>
                        </a>
                    </span>
                
                
                    <span class="button next">
                        <a href="https://oneirical.github.io/bevyrage/">
                            <span class="button__text">Bashing Bevy To Bait Internet Strangers Into Improving My Code</span>&nbsp;
                            <span class="button__icon">→</span>
                        </a>
                    </span>
                </div>
        </div>
    
    </div>

    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright">
                        <span>© 
    2025
 Julien Robert</span>
                    <span class="copyright-theme">
                        <span class="copyright-theme-sep">:: </span>
                        Theme: <a href="https://github.com/pawroman/zola-theme-terminimal/">Terminimal</a> by pawroman
                    </span>
                </div>
            </div>
    </footer>
    

</div>
</body>

</html>
